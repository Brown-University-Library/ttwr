import re
from collections import OrderedDict
from django.http import Http404
from django.db import models
from django.urls import reverse
from . import app_settings
import requests
import json
from eulxml.xmlmap import load_xmlobject_from_string
from bdrxml import mods
from django.db import IntegrityError

# Database Models
class Biography(models.Model):

    name = models.CharField(max_length=254, help_text='Enter name as it appears in the book metadata')
    trp_id = models.CharField(max_length=15, unique=True, blank=True, help_text='Optional: This value will be auto-generated by the server if the field is left blank or non-unique value is entered')
    alternate_names = models.CharField(max_length=254, null=True, blank=True, help_text='Optional: enter alternate names separated by a semi-colon')
    external_id = models.CharField(max_length=254, null=True, blank=True, help_text='Optional: enter Ulan id in the form of a URL; if there is no Ulan id, enter LCCN in the form of a URL')
    birth_date = models.CharField(max_length=25, null=True, blank=True, help_text='Optional: enter birth date as yyyy-mm-dd (for sorting and filtering)')
    death_date = models.CharField(max_length=25, null=True, blank=True, help_text='Optional: enter death date as yyyy-mm-dd')
    roles = models.CharField(max_length=254, null=True, blank=True, help_text='Optional: enter roles, separated by a semi-colon')
    bio = models.TextField()

    class Meta:
        verbose_name_plural = 'biographies'
        ordering = ['name']

    def books(self):
        return Book.search(query='genre_aat:books+AND+name:"%s"' % self.name )

    def prints(self):
        return Book.search(query='(genre_aat:"etchings (prints)"+OR+genre_aat:"engravings (prints)")+AND+name:"%s"' % self.name )

    def format_trp_id(self, trp_id):
        return '%04d' % int(trp_id)

    def related_essays(self):
        return self.essay_set.all()

    def _get_trp_id(self):
        ordered_bios = Biography.objects.order_by('-trp_id')
        if not ordered_bios:
            return '0001'
        index = 0
        last_bio = ordered_bios[index]
        while last_bio.trp_id != self.format_trp_id(last_bio.trp_id):
            last_bio = ordered_bios[index+1]
        last_trp_id = int(last_bio.trp_id)
        new_trp_id = last_trp_id + 1
        return '%04d' % new_trp_id

    def save(self, *args, **kwargs):
        if not self.trp_id:
            self.trp_id = self._get_trp_id()
        else:
            self.trp_id = self.format_trp_id(self.trp_id)     
        if self.roles:
            self.roles = self.roles.replace(",",";");
        try:
            super(Biography, self).save(*args, **kwargs)
        except IntegrityError as e:
            self.trp_id = self._get_trp_id()
            super(Biography, self).save(*args, **kwargs)

    def __str__(self):
        return u'%s (%s)' % (self.name, self.trp_id)


class Document(models.Model):
     slug = models.SlugField(max_length=191)
     title = models.CharField(max_length=254)
     summary = models.TextField()
     text = models.TextField()
     document_file = models.FileField(blank=True)
     document_link = models.URLField()
     people = models.ManyToManyField(Biography, blank=True, help_text='List of people associated with this essay.')
     consagra = models.BooleanField()

     def __str__(self):
        return 'Document: {}'.format(self.title)

class Shop(models.Model):
    slug = models.SlugField(max_length=191)
    title = models.CharField(max_length=254)
    text = models.TextField()
    people = models.ManyToManyField(Biography, blank=True, help_text='List of people associated with this Shop.')
    pids = models.CharField(max_length=254, null=True, blank=True, help_text='Comma-separated list of pids for books or prints associated with this shop.')
    family = models.CharField(max_length=254, null=True, blank=True, help_text='Enter Family associated with shop')
    start_date = models.CharField(max_length=25, null=True, blank=True, help_text='Optional: enter birth date as yyyy-mm-dd (for sorting and filtering)')
    end_date = models.CharField(max_length=25, null=True, blank=True, help_text='Optional: enter death date as yyyy-mm-dd')
    documents = models.ManyToManyField(Document, blank=True, help_text='List of documents associated with this shop.')
     

    def related_essays(self):
        return self.essay_set.all()

    def related_works(self):
        num_prints_estimate = 6000
        if not self.pids:
            return {}
        else:
            query = self._get_related_works_query()
            query_uri = 'https://%s/api/search/?q=%s' % (app_settings.BDR_SERVER, query)
            r = requests.get(query_uri)
            response_data = r.json() #automatically parses the content into json
            annotations = response_data['response']['docs']
            return annotations

    def _get_related_works_query(self):
        if self.pids is None:
            return None
        else:
            pidlist = ["pid:\"%s:%s\"" % (app_settings.PID_PREFIX, p) for p in self.pids.split(",")]
            query = "ir_collection_id:621+AND+display:BDR_PUBLIC+AND+(%s)&fl=primary_title,rel_has_pagination_ssim,rel_is_part_of_ssim,creator,pid,genre" % "+OR+".join(pidlist)
            return query

     
class Essay(models.Model):
    slug = models.SlugField(max_length=191)
    author = models.CharField(max_length=254)
    title = models.CharField(max_length=254)
    text = models.TextField()
    pids = models.CharField(max_length=254, null=True, blank=True, help_text='Comma-separated list of pids for books or prints associated with this essay.')
    people = models.ManyToManyField(Biography, blank=True, help_text='List of people associated with this essay.')
    shops = models.ManyToManyField(Shop, blank=True, help_text='List of shops associated with this essay.')
    is_note = models.BooleanField(default=False)

    def preview(self):
        return self.text[:254]

    def related_works(self):
        num_prints_estimate = 6000
        if not self.pids:
            return {}
        else:
            query = self._get_related_works_query()
            query_uri = 'https://%s/api/search/?q=%s' % (app_settings.BDR_SERVER, query)
            r = requests.get(query_uri)
            response_data = r.json() #automatically parses the content into json
            annotations = response_data['response']['docs']
            return annotations

    def _get_related_works_query(self):
        if self.pids is None:
            return None
        else:
            pidlist = ["pid:\"%s:%s\"" % (app_settings.PID_PREFIX, p) for p in self.pids.split(",")]
            query = "ir_collection_id:621+AND+display:BDR_PUBLIC+AND+(%s)&fl=primary_title,rel_has_pagination_ssim,rel_is_part_of_ssim,creator,pid,genre" % "+OR+".join(pidlist)
            return query

class Static(models.Model):
    title = models.CharField(max_length=254)
    text = models.TextField()


class Genre(models.Model):
    text = models.CharField(max_length=50, unique=True)
    external_id = models.CharField(max_length=50, blank=True)

    def __str__(self):
        return self.text


class Role(models.Model):
    text = models.CharField(max_length=50, unique=True)
    external_id = models.CharField(max_length=50, blank=True)

    def __str__(self):
        return self.text


# Non-Database Models

def zoom_viewer_url(pid):
    return 'https://%s/viewers/image/zoom/%s?first_child_only=1' % (app_settings.BDR_SERVER, pid)


def annotation_xml_url(pid):
    return 'https://%s/storage/%s/MODS/' % (app_settings.BDR_SERVER, pid)


class BDRObject:

    def __init__(self, data=None, parent=None):
        self.data = data or {}
        self.parent = parent

    def __bool__(self):
        return bool(self.data)

    def __getattr__(self, name):
        if name in self.data:
            return self.data.get(name)
        else:
            raise AttributeError

    def __eq__(self, other):
        sid = self.data.get("pid", "").split(":")[-1]
        oid = other.data.get("pid", "").split(":")[-1]
        return sid == oid

    def __contains__(self, item):
        return item in self.data

    OBJECT_TYPE = "*"
    @classmethod
    def search(cls, query="*", rows=6000):
        url1 = 'https://%s/api/collections/621/?q=%s&fq=object_type:%s&fl=*&fq=discover:BDR_PUBLIC&rows=%s' % (app_settings.BDR_SERVER, query, cls.OBJECT_TYPE, rows)
        objects_json = json.loads(requests.get(url1).text)
        num_objects = objects_json['items']['numFound']
        if num_objects>rows: #only reload if we need to find more bdr_objects
            return cls.search(query, num_objects)
        return [ cls(data=obj_data) for obj_data in objects_json['items']['docs'] ]


    @classmethod
    def get(cls, pid):
        json_uri='https://%s/api/items/%s/?q=*&fl=*' % (app_settings.BDR_SERVER, pid)
        resp = requests.get(json_uri)
        if not resp.ok:
             return cls()
        return cls(data=json.loads(resp.text))

    @classmethod
    def get_or_404(cls, pid):
        obj = cls.get(pid)
        if not obj:
            raise Http404
        return obj


    @property
    def id(self):
        return self.data.get('pid','').split(":")[-1]

    def _get_full_title(self):
        data = self.data
        if 'nonsort' not in data:
            return u'%s' % data['primary_title']
        if data['nonsort'].endswith(u"'"):
            return u'%s%s' % (data['nonsort'], data['primary_title'])
        return u'%s %s' % (data['nonsort'], data['primary_title'])

    @property
    def studio_uri(self):
        return self.uri

    def title(self):
        return self._get_full_title()

    def title_sort(self):
        return self.data['primary_title'].lower()

    def sort_key(self, sort_by):
        if(sort_by == 'title_sort'):
            return (self.title_sort(), self.date())
        elif(sort_by == 'authors'):
            return (self.authors(), self.title_sort(), self.date())
        return (self.date(), self.title_sort())

    def alt_titles(self):
        if "mods_title_alt" in self.data:
            return self.mods_title_alt
        return []

    def date(self):
        if "dateCreated" in self.data:
            return self.dateCreated[0:4]
        if "dateIssued" in self.data:
            return self.dateIssued[0:4]
        return "n.d"

    def authors(self):
        if "contributor_display" in self.data:
            return "; ".join(self.contributor_display)
        return "Anonymous"

    @property
    def thumbnail_src(self):
        return 'https://%s/viewers/image/thumbnail/%s/' % (app_settings.BDR_SERVER, self.pid)


class Book(BDRObject):
    OBJECT_TYPE = "implicit-set"
    CUTOFF = 80
    SORT_OPTIONS = OrderedDict([
        ( 'authors', 'authors' ),
        ( 'title', 'title_sort' ),
        ( 'date', 'date' ),
    ])

    @property
    def thumbnail_url(self):
        return  reverse('thumbnail_viewer', kwargs={'book_id': self.id})

    @property
    def short_title(self):
        if self.title_cut():
            return self.title()[0:Book.CUTOFF-3]+"..."
        return self.title()

    def title_cut(self):
        return bool(len(self.title()) > Book.CUTOFF)

    def port_url(self):
        return 'https://%s/viewers/readers/portfolio/%s/' % (app_settings.BDR_SERVER, self.pid)

    def book_url(self):
        return 'https://%s/viewers/readers/set/%s/' % (app_settings.BDR_SERVER, self.pid)

    def pages(self):
        return [ Page(data=page_data, parent=self) for page_data in self.relations['hasPart'] ]

    def essays(self):
        return Essay.objects.filter(pids__contains = self.pid[4:])


class Page(BDRObject):
    SORT_OPTIONS = OrderedDict([
        ( 'authors', 'authors' ),
        ( 'title', 'title' ),
        ( 'date', 'date' ),
    ])
    OBJECT_TYPE = "implicit-set" #TODO change to something more page appropriate

    def embedded_viewer_src(self):
        return zoom_viewer_url(self.pid)

    def url(self):
        return reverse('book_page_viewer', args=[self.parent.id, self.id])

    def essays(self):
        return Essay.objects.filter(pids__contains = self.pid.split(":")[1])


class Print(Page):

    @staticmethod
    def find_prints(collection):
        collection_query = ''
        if(collection == 'chinea'):
            collection_query = '+AND+(primary_title:"Chinea"+OR+subtitle:"Chinea")'
        elif(collection == 'buonanno'):
            collection_query = '+AND+((note:buonanno))'
        elif(collection == 'not'):
            collection_query = '+NOT+primary_title:"Chinea"+NOT+subtitle:"Chinea"'

        num_prints_estimate = 1000
        query = 'ir_collection_id:621+AND+(genre_aat:"etchings (prints)"+OR+genre_aat:"engravings (prints)")%s' % collection_query
        url = 'https://%s/api/search/?q=%s&rows=%s' % (app_settings.BDR_SERVER, query, num_prints_estimate)
        r = requests.get(url)
        if r.ok:
            prints_json = json.loads(r.text)
            prints_list = []
            pages = []
            pages1 = []
            for index, doc in enumerate(prints_json['response']['docs']):
                pages.append(Print.get_print_info_from_solr_doc(doc, collection))
                if index > 1:
                    pages1.append(Print.get_print_info_from_solr_doc(doc, collection))
            prints_list = [pages, pages1]
            return prints_list
        else:
            logger.error('error fetching prints: %s - %s' % (r.status_code, r.content))
            return []

    @staticmethod
    def get_print_info_from_solr_doc(solr_doc, collection):
        current_print={}
        title = get_full_title_static(solr_doc)

        current_print['in_chinea'] = 0
        current_print['in_buonanno'] = 0
        
        for search_term, attribute in [('chinea', 'in_chinea'),('buonanno', 'in_buonanno')]:
            if collection == search_term:
                current_print[attribute] = 1
            elif (re.search(search_term, title, re.IGNORECASE) or (re.search(search_term, solr_doc[u'subtitle'][0], re.IGNORECASE) if u'subtitle' in solr_doc else False)):
                current_print[attribute] = 1

        pid = solr_doc['pid']
        current_print['id'] = pid.split(":")[1]
        short_title = title
        current_print['title_cut'] = 0
        if len(title)>60:
            short_title = title[0:57]+"..."
            current_print['title_cut'] = 1
        current_print['title'] = title
        current_print['short_title'] = short_title

        try:
            current_print['date'] = solr_doc['dateCreated'][0:4]
        except KeyError:
            try:
                current_print['date'] = solr_doc['dateIssued'][0:4]
            except KeyError:
                current_print['date'] = "n.d."

        try:
            author_list = solr_doc['contributor_display']
        except KeyError:
            try:
                author_list = solr_doc['contributor']
            except:
                author_list = ["Unknown"];
        authors=""
        for i in range(len(author_list)):
            if i == len(author_list)-1:
                authors += author_list[i]
            else:
                authors += author_list[i] + "; "
        current_print['authors'] = authors

        current_print['studio_uri'] = 'https://%s/studio/item/%s/' % (app_settings.BDR_SERVER, pid)
        current_print['thumbnail_url'] = reverse('specific_print', args=[current_print['id']])
        current_print['det_img_viewer'] = zoom_viewer_url(pid)
        return current_print

    def url(self):
        return reverse('specific_print', args=[self.id,])


def _get_annotations_for_person(bio_name):
    #Look up every annotation for a person
    num_prints_estimate = 6000
    query_uri = 'https://%s/api/search/?q=ir_collection_id:621+AND+object_type:"annotation"+AND+contributor:"%s"+AND+display:BDR_PUBLIC&rows=%s&fl=rel_is_annotation_of_ssim,primary_title,pid,nonsort' % (app_settings.BDR_SERVER, bio_name, num_prints_estimate)
    annotations = json.loads(requests.get(query_uri).text)['response']['docs']
    return annotations


def _get_pages_from_annotations(annotations):
    # create a list of pages (or prints) the annotations are attached to
    pages = dict([(page['rel_is_annotation_of_ssim'][0].split(u':')[-1], page) for page in annotations])
    for page_id in pages:
        page = pages[page_id]
        page['title'] = get_full_title_static(page)
        page['page_id'] = page_id
        page['id'] = page_id.split(u':')[-1]
        page['thumb'] = u"https://%s/viewers/image/thumbnail/%s/"  % (app_settings.BDR_SERVER, page['rel_is_annotation_of_ssim'][0])
    return pages


def _sort_book_pages(books):
    for b in books:
        books[b]['pages'] = sorted(books[b]['pages'].items())
    return books


def annotations_by_books_and_prints(bio_name, group_amount=50):
    # Might need some cleaning up later, see if we can use objects here

    annotations = _get_annotations_for_person(bio_name)
    pages = _get_pages_from_annotations(annotations)
    pids_of_pages_to_look_up = [a['rel_is_annotation_of_ssim'][0].replace(':', '\:') for a in annotations]

    prints = []
    books = {}
    num_pages = len(pids_of_pages_to_look_up)
    i = 0
    # Look up which books those pages are part of in groups of group_amount
    # (by default 50, any longer tends to break the request because the URL is too long)
    while(i < num_pages):
        group_of_pids = pids_of_pages_to_look_up[i : i+group_amount]
        pids_query = "(pid:" + ("+OR+pid:".join(group_of_pids)) + ")"
        book_query = u"https://%s/api/search/?q=%s+AND+display:BDR_PUBLIC&fl=pid,primary_title,nonsort,object_type,rel_is_part_of_ssim,rel_has_pagination_ssim&rows=%s" % (app_settings.BDR_SERVER, pids_query, group_amount)
        data = json.loads(requests.get(book_query).text)
        looked_up_pages = data['response']['docs']

        # Create a dict that maps book pids to a list of pages for that book
        # essentially:
        # {
        #    "123456": {
        #                 'pid':'123456'
        #                 'title':"Sculpture in Rome"
        #                 'pages': [{...}, {...}, ...] (all pages in this book with annotations)
        #              }
        #    "456789": {
        #                  ...
        #              }
        #    ...
        # }
        # Also deals with any prints that came up in the search
        for page in looked_up_pages:
            try:
                book_id = page['rel_is_part_of_ssim'][0].split(u':')[-1]
                n = int(page['rel_has_pagination_ssim'][0])

                if(book_id not in books):
                    #add new book to our list of books
                    books[book_id] = {}
                    books[book_id]['title'] = get_full_title_static(page)
                    books[book_id]['pages'] = dict()
                books[book_id]['pages'][n] = pages[page['pid'].split(u':')[-1]]
            except KeyError:
                #page has no rel_is_part_of_ssim, so it's a print
                p_obj = {}
                p_obj['pid'] = page['pid']
                p_obj['primary_title'] = get_full_title_static(page)
                prints.append(Print(data=p_obj))

        i += group_amount

    books = _sort_book_pages(books)
    return (books,prints)


class Annotation:

    @classmethod
    def from_form_data(cls, image_pid, annotator, form_data, person_formset_data, inscription_formset_data, pid=None):
        return cls(image_pid=image_pid, annotator=annotator, pid=pid, form_data=form_data, person_formset_data=person_formset_data, inscription_formset_data=inscription_formset_data)

    @classmethod
    def from_pid(cls, pid):
        r = requests.get(annotation_xml_url(pid))
        if not r.ok:
            raise Exception('error retrieving annotation data for %s: %s - %s' % (pid, r.status_code, r.content))
        mods_obj = load_xmlobject_from_string(r.content, mods.Mods)
        return cls(pid=pid, mods_obj=mods_obj)

    def __init__(self, image_pid=None, annotator=None, pid=None, form_data=None, person_formset_data=[], inscription_formset_data=[], mods_obj=None):
        self._image_pid = image_pid #pid of the object that we're adding the annotation for
        self._annotator = annotator
        self._form_data = form_data
        self._person_formset_data = [p for p in person_formset_data if p and p['person']]
        self._inscription_formset_data = [i for i in inscription_formset_data if i and i['text']]
        self._mods_obj = mods_obj
        self._pid = pid

    def add_form_data(self, annotator, form_data, person_formset_data, inscription_formset_data):
        #this is for adding the new form data when updating an annotation
        self._annotator = annotator
        self._form_data = form_data
        self._person_formset_data = [p for p in person_formset_data if p and p['person']]
        self._inscription_formset_data = [i for i in inscription_formset_data if i and i['text']]

    def get_form_data(self):
        if not self._form_data:
            self._form_data = {}
            if not self._mods_obj:
                raise Exception('no form data or mods obj')
            title1 = self._mods_obj.title_info_list[0]
            self._form_data['title'] = title1.title
            title1_lang = title1.node.get('lang')
            if title1_lang:
                self._form_data['title_language'] = title1_lang
            if len(self._mods_obj.title_info_list) > 1:
                self._form_data['english_title'] = self._mods_obj.title_info_list[1].title
            if self._mods_obj.genres and self._mods_obj.genres[0].text:
                genre = Genre.objects.get(text=self._mods_obj.genres[0].text)
                self._form_data['genre'] = genre.id
            if self._mods_obj.abstract:
                self._form_data['abstract'] = self._mods_obj.abstract.text
            if self._mods_obj.origin_info:
                if self._mods_obj.origin_info.other:
                    self._form_data['impression_date'] = self._mods_obj.origin_info.other[0].date
        return self._form_data

    def get_person_formset_data(self):
        if not self._person_formset_data:
            if not self._mods_obj:
                raise Exception('no person formset data or mods obj')
            self._person_formset_data = []
            for name in self._mods_obj.names:
                p = {}
                trp_id = name.node.get('{%s}href' % app_settings.XLINK_NAMESPACE)
                trp_id = '%04d' % int(trp_id)
                try:
                    person = Biography.objects.get(trp_id=trp_id)
                except Biography.DoesNotExist:
                    raise Exception('no person with trp_id %s' % trp_id)
                p['person'] = person
                role_text = name.roles[0].text
                try:
                    role = Role.objects.get(text=role_text)
                except Role.DoesNotExist:
                    raise Exception('no role with text %s' % role_text)
                p['role'] = role
                self._person_formset_data.append(p)
        return self._person_formset_data

    def get_inscription_formset_data(self):
        if not self._inscription_formset_data:
            if not self._mods_obj:
                raise Exception('no inscription formset data or mods obj')
            self._inscription_formset_data = [{'text': note.text, 'location': note.label} for note in self._mods_obj.notes if note.type=='inscription']
        return self._inscription_formset_data

    def get_mods_obj(self, update=False):
        if self._mods_obj:
            #if we have mods already, and we're not updating, just return it
            if not update:
                return self._mods_obj
        else: #no self._mods_obj
            if update:
                raise Exception('no mods obj - can\'t update')
            self._mods_obj = mods.make_mods()
        #at this point, we want to put the form data into the mods obj (could be update or new)
        self._mods_obj.title_info_list = [] #clear out any old titles
        title = mods.TitleInfo()
        title.title = self._form_data['title']
        if self._form_data['title_language']:
            title.node.set('lang', self._form_data['title_language'])
        self._mods_obj.title_info_list.append(title)
        if self._form_data['english_title']:
            english_title = mods.TitleInfo()
            english_title.title = self._form_data['english_title']
            english_title.node.set('lang', 'en')
            self._mods_obj.title_info_list.append(english_title)
        if self._form_data['genre']:
            self._mods_obj.genres = [] #clear out any old genres
            genre = mods.Genre(text=self._form_data['genre'].text)
            genre.authority = 'aat'
            self._mods_obj.genres.append(genre)
        if self._form_data['abstract']:
            if not self._mods_obj.abstract:
                self._mods_obj.create_abstract()
            self._mods_obj.abstract.text = self._form_data['abstract'] #overwrites old abstract if present
        if self._form_data['impression_date']:
            #clear out old dateOther data, or create originInfo if needed
            if self._mods_obj.origin_info:
                self._mods_obj.origin_info.other = []
            else:
                self._mods_obj.create_origin_info()
            date_other = mods.DateOther(date=self._form_data['impression_date'])
            date_other.type = 'impression'
            self._mods_obj.origin_info.other.append(date_other)
        #clear out any old names:
        #   if this is a new object, there aren't any names anyway.
        #   if this is an update, either the new names will be put in, or they don't want any names.
        self._mods_obj.names = []
        for p in self._person_formset_data:
            name = mods.Name()
            np = mods.NamePart(text=p['person'].name)
            name.name_parts.append(np)
            role = mods.Role(text=p['role'].text)
            name.roles.append(role)
            href = '{%s}href' % app_settings.XLINK_NAMESPACE
            name.node.set(href, p['person'].trp_id)
            self._mods_obj.names.append(name)
        #clear out old notes data, preserving any annotor info
        self._mods_obj.notes = [note for note in self._mods_obj.notes if note.type == 'resp']
        for i in self._inscription_formset_data:
            note = mods.Note(text=i['text'])
            note.type = 'inscription'
            note.label = i['location']
            self._mods_obj.notes.append(note)
        annotator_note = mods.Note(text=self._annotator)
        annotator_note.type = 'resp'
        self._mods_obj.notes.append(annotator_note)
        return self._mods_obj

    def to_mods_xml(self, update=False):
        return self.get_mods_obj(update).serialize().decode('utf8')

    def _get_params(self):
        params = {'identity': app_settings.BDR_IDENTITY, 'authorization_code': app_settings.BDR_AUTH_CODE}
        params['mods'] = json.dumps({u'xml_data': self.to_mods_xml()})
        params['ir'] = json.dumps({'parameters': {'ir_collection_id': 621}})
        params['rels'] = json.dumps({u'isAnnotationOf': self._image_pid})
        params['rights'] = json.dumps({'parameters': {'owner_id': app_settings.BDR_IDENTITY, 'additional_rights': 'BDR_PUBLIC#display'}})
        params['content_model'] = 'Annotation'
        return params

    def _get_update_params(self):
        params = {'identity': app_settings.BDR_IDENTITY, 'authorization_code': app_settings.BDR_AUTH_CODE}
        params['mods'] = json.dumps({u'xml_data': self.to_mods_xml(update=True)})
        if self._pid:
            params['pid'] = self._pid
        else:
            raise Exception('no pid for annotation update')
        return params

    def save_to_bdr(self):
        params = self._get_params()
        r = requests.post(app_settings.BDR_POST_URL, data=params)
        if r.ok:
            return {'pid': json.loads(r.text)['pid']}
        else:
            raise Exception('error posting new annotation for %s: %s - %s' % (self._image_pid, r.status_code, r.content))

    def update_in_bdr(self):
        params = self._get_update_params()
        r = requests.put(app_settings.BDR_POST_URL, data=params)
        if r.ok:
            return {'status': 'success'}
        else:
            raise Exception('error putting update to %s: %s - %s' % (self._pid, r.status_code, r.content))


def get_full_title_static(data):
    if 'primary_title' not in data:
        return 'No Title'
    if 'nonsort' in data:
        if data['nonsort'].endswith(u"'"):
            return '%s%s' % (data['nonsort'], data['primary_title'])
        else:
            return '%s %s' % (data['nonsort'], data['primary_title'])
    else:
        return '%s' % data['primary_title']

